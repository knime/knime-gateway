/*
 * ------------------------------------------------------------------------
 *
 *  Copyright by KNIME GmbH, Konstanz, Germany
 *  Website: http://www.knime.org; Email: contact@knime.org
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License, Version 3, as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, see <http://www.gnu.org/licenses>.
 *
 *  Additional permission under GNU GPL version 3 section 7:
 *
 *  KNIME interoperates with ECLIPSE solely via ECLIPSE's plug-in APIs.
 *  Hence, KNIME and ECLIPSE are both independent programs and are not
 *  derived from each other. Should, however, the interpretation of the
 *  GNU GPL Version 3 ("License") under any applicable laws result in
 *  KNIME and ECLIPSE being a combined program, KNIME GMBH herewith grants
 *  you the additional permission to use and propagate KNIME together with
 *  ECLIPSE with only the license terms in place for ECLIPSE applying to
 *  ECLIPSE and the GNU GPL Version 3 applying for KNIME, provided the
 *  license terms of ECLIPSE themselves allow for the respective use and
 *  propagation of ECLIPSE together with KNIME.
 *
 *  Additional permission relating to nodes for KNIME that extend the Node
 *  Extension (and in particular that are based on subclasses of NodeModel,
 *  NodeDialog, and NodeView) and that only interoperate with KNIME through
 *  standard APIs ("Nodes"):
 *  Nodes are deemed to be separate and independent programs and to not be
 *  covered works.  Notwithstanding anything to the contrary in the
 *  License, the License does not apply to Nodes, you are not required to
 *  license Nodes under the License, and you are granted a license to
 *  prepare and propagate Nodes, in each case even if such Nodes are
 *  propagated with or for interoperation with KNIME.  The owner of a Node
 *  may freely choose the license terms applicable to such Node, including
 *  when such Node is propagated with or for interoperation with KNIME.
 * ---------------------------------------------------------------------
 *
 */
package $package;

import static org.junit.Assert.assertEquals;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;

import org.junit.Test;
import org.knime.gateway.entities.EntityBuilderManager;
#foreach( $import in $imports)
import $import;
#end

/**
 *
 * @author Martin Horn, University of Konstanz
 */
// AUTO-GENERATED CODE; DO NOT MODIFY
public class ${name}Test {

    private static Random RAND = new Random();

    @Test
    public void test() {
        List<Object> valueList = createValueList();
        ${name} ent = createEnt(valueList);
        testEnt(ent, valueList);
    }

    public static ${name} createEnt(final List<Object> valueList) {
        ${name}Builder builder = EntityBuilderManager.builder(${name}Builder.class);
#foreach( $field in $fields )
		#set($count = $foreach.count - 1)
#if($field.getType().isList())
		List<$field.getType().getTypeParameter(0).toString()> list$count = new ArrayList<>();
		List<Object> subList$count = (List<Object>) valueList.get($count);
		for(int i = 0; i < subList${count}.size(); i++) {
#if($field.getType().isEntityList())
			list${count}.add(${field.getType().getTypeParameter(0).toString("","Test")}.createEnt((List<Object>) subList${count}.get(i)));
#else
			list${count}.add((${field.getType().getTypeParameter(0).toString()}) subList${count}.get(i));
#end
		}
		builder.set${field.getName()}(list$count);
#elseif($field.getType().isMap())
		Map<$field.getType().getTypeParameter(0).toString(), $field.getType().getTypeParameter(1).toString()> map$count = new HashMap<>();
		Map<$field.getType().getTypeParameter(0).toString(), Object> subMap$count = (Map<$field.getType().getTypeParameter(0).toString("",""), Object>) valueList.get($count);
		for($field.getType().getTypeParameter(0).toString() key : subMap${count}.keySet()) {
#if($field.getType().isEntityMap())
			map${count}.put(key, ${field.getType().getTypeParameter(1).toString("","Test")}.createEnt((List<Object>) subMap${count}.get(key)));
#else
			map${count}.put(key, (${field.getType().getTypeParameter(1).toString()}) subMap${count}.get(key));
#end
		}
		builder.set${field.getName()}(map${count});
#elseif($field.getType().isPrimitive() || $field.getType().isPrimitiveOptional())
		builder.set${field.getName()}((${field.getType().toString()}) valueList.get($count));
#elseif($field.getType().isEntityOptional())
		builder.set${field.getName()}(Optional.of(${field.getType().getTypeParameter(0).toString("","Test")}.createEnt((List<Object>) valueList.get($count))));
#else
		builder.set${field.getName()}(${field.getType().toString("","Test")}.createEnt((List<Object>) valueList.get($count)));
#end
#end
        return builder.build();
    }

    public static void testEnt(final ${name} ent, final List<Object> valueList) {
#foreach( $field in $fields )
#set($count = $foreach.count - 1)
#if($field.getType().isList())
		List<Object> subValueList$count = (List<Object>) valueList.get($count);
		List<${field.getType().getTypeParameter(0).toString()}> subList$count =  ent.get$field.getName()();
		for(int i = 0; i < subList${count}.size(); i++) {
#if($field.getType().isEntityList())
			${field.getType().getTypeParameter(0).toString("", "Test")}.testEnt(subList${count}.get(i), (List<Object>) subValueList${count}.get(i));
#else
			assertEquals(subList${count}.get(i), subValueList${count}.get(i));
#end
		}
#elseif($field.getType().isMap())
		Map<${field.getType().getTypeParameter(0).toString()}, List<Object>> subValueMap$count = (Map<${field.getType().getTypeParameter(0).toString()}, List<Object>>) valueList.get($count);
		Map<${field.getType().getTypeParameter(0).toString()}, ${field.getType().getTypeParameter(1).toString()}> subMap$count =  ent.get$field.getName()();
		for(${field.getType().getTypeParameter(0).toString()} key : subMap${count}.keySet()) {
#if($field.getType().isEntityMap())
			${field.getType().getTypeParameter(1).toString("", "Test")}.testEnt(subMap${count}.get(key), (List<Object>) subValueMap${count}.get(key));
#else
			assertEquals(subMap${count}.get(key), subValueMap${count}.get(key));
#end
		}
#elseif($field.getType().isPrimitive())
		assertEquals(ent.get$field.getName()(), ($field.getType().toString()) valueList.get($count));
#elseif($field.getType().isEntityOptional())
		${field.getType().getTypeParameter(0).toString("", "Test")}.testEnt(ent.get$field.getName()().get(), (List<Object>) valueList.get($count));
#elseif($field.getType().isPrimitiveOptional())
		assertEquals(ent.get$field.getName()().get(),(($field.getType().toString()) valueList.get($count)).get());
#else
		${field.getType().toString("", "Test")}.testEnt(ent.get$field.getName()(), (List<Object>) valueList.get($count));
#end
#end
    }

    public static List<Object> createValueList() {
        List<Object> valueList = new ArrayList<Object>();
#foreach( $field in $fields )
#set($type = $field.getType())
#set($idx = $foreach.count)
#if($type.isEntityList())
 		List<List<Object>> subList${foreach.count} = new ArrayList<>();
#foreach($i in [1..5])
		subList${idx}.add(${type.getTypeParameter(0).toString("","Test")}.createValueList());
#end
 		valueList.add(subList${foreach.count});
#elseif($type.isPrimitiveList())
 		List<Object> subList${foreach.count} = new ArrayList<>();
#foreach($i in [1..5])
		subList${idx}.add(${type.getTypeParameter(0).createRandomPrimitive($i)});
#end
 		valueList.add(subList${foreach.count});
#elseif($type.isEntityMap())
 		Map<${type.getTypeParameter(0).toString()}, List<Object>> subMap${foreach.count} = new HashMap<>();
#foreach($i in [1..5])
 		subMap${idx}.put(${type.getTypeParameter(0).createRandomPrimitive($i)}, ${type.getTypeParameter(1).toString("","Test")}.createValueList());
#end
 		valueList.add(subMap${foreach.count});
#elseif($type.isPrimitiveMap())
		Map<${type.getTypeParameter(0).toString()}, Object> subMap${foreach.count} = new HashMap<>();
#foreach($i in [1..5])
		subMap${idx}.put(${type.getTypeParameter(0).createRandomPrimitive($i)}, ${type.getTypeParameter(1).createRandomPrimitive($i)});
#end
 		valueList.add(subMap${foreach.count});
#elseif($type.isPrimitive())
 		valueList.add(${type.createRandomPrimitive($foreach.count)});
#elseif($type.isPrimitiveOptional())
		valueList.add(Optional.of(${type.getTypeParameter(0).createRandomPrimitive($foreach.count)}));
#elseif($type.isEntityOptional())
		valueList.add(${type.getTypeParameter(0).toString("","Test")}.createValueList());
#else
 		valueList.add(${type.toString("","Test")}.createValueList());
#end

#end
        return valueList;
    }

}
